#include <iostream>
#include <vector>
using namespace std;

// Задача: Автоматический анализ программ
// вход: n - число индексов переменных (начинаем с 1 до n)
// e - кол-во равенств в системе 
// d - кол-во неравенств в системе
// необходимо проверить, можно ли просвоить переменным некие целые значения,
// чтобы выполнялись все равенства и неравенства в системе 
// выход: 1 - можно, 0 - нельзя 

// задача полностью решается с помощью струткуры данных Disjoint Sets, ктр описана классом ниже 

// класс Непересекающиеся множества 
class DisjointSets {
public:
    vector<int> parent; // атрибут родители текущих вершин 
    vector<int> rang; // атрибут ранг текущих вершин 
public:
    
    DisjointSets(int n) { 
        parent.resize(n); // теперь вектор на n элементов 
        rang.resize(n);
    }

    void make_set(int i) { // создание одноэлементного множества singleton 
        parent[i] = i; // его родитель он сам 
        rang[i] = 0; // его ранг (высота поддерева с корнем в нем) равен 0
    }

    // поиск идентификатора (корня) множества делаем через эвристику сжатия путей
    // это рекурсивная оптимизированная функция 
    int find_id(int i) {
        if (i != parent[i]) { // не корень 
            parent[i] = find_id(parent[i]);
        }
        return parent[i];
    }

    void union_sets(int i, int j) { // объединение двух множеств 
        int id_i = find_id(i);
        int id_j = find_id(j);
        if (id_i == id_j) return; // уже в одном дереве (не объединяем)
        // пользуемся эвристикой объединения по рангу, чтобы минимизировать высоту дерева 
        if (rang[id_j] > rang[id_i]) {
            parent[id_i] = id_j; // к более высокому дереву подвешиваем более низкое 
        }
        else { // <=
            parent[id_j] = id_i;
            if (rang[id_j] == rang[id_i]) {
                rang[id_i] += 1;
            }
        }
    }
};

int main()
{
    int n, e, d;
    cin >> n >> e >> d;
    DisjointSets ds(n);
    // создаем одноэлементные множества для каждого числа 
    for (int i = 0; i < n; ++i) {
        ds.make_set(i);
    }
    int a, b;
    // считываем все равенства в системе 
    for (int i = 0; i < e; ++i) {
        cin >> a >> b;
        ds.union_sets(a-1, b-1);
    }
    bool f = true;
    // считываем все неравенсвта в системе и проверяем их достоверность 
    for (int i = 0; i < d; ++i) {
        cin >> a >> b;
        // чтобы поддерживать неравенство - элементы дб в разных множествах 
        if (ds.find_id(a-1) == ds.find_id(b-1)) { // элементы в одном множестве 
            cout << 0;
            f = false;
            break;
        }
    }
    if (f) {
        cout << 1;
    }
    return 0;
}

